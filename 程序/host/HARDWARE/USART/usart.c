#include "usart.h"

unsigned char R_STA = 0; 	//串口接收状态
unsigned char res = 0;
unsigned char idata str[USART_SIZE] = {0x39,0x00,0x00,0x00,0x00,0x93};	//串口数据缓存 0x39起 0x93结束

/*******************************************************************************
* 函数名         : UART_Init
* 功能		  	 : 初始化串口
* 输入			 ：无
* 输出			 : 无
*******************************************************************************/
void UART_Init() 
{  
	TMOD|=0X20;  	//定时器1定时器方式 工作模式2
	SCON=0X51; 		//选择工作模式1使能接收，允许发送，允许接收	
	//EA=1; 			//开总中断	
	ES=1;  			//开串口中断
	ET1=0;  		//开定时器中断	
	PCON=0X80; 		//8位自动重载，波特率加倍	
	TH1=0XFA;  		//波特率9600
	TL1=0XFA; 
	TR1=1; 			//打开定时器1
}


/*******************************************************************************
* 函数名         : UART_Putch
* 功能		  	 : 发送一帧数据
* 输入			 ：数组地址
* 输出			 : 无
*******************************************************************************/
void UART_Putch(uchar idata *dat)  
{
   uchar i;
   for(i=0 ;i<6;i++)	
   {
			SBUF=dat[i]; 		//把数据送到sbuf缓冲器中					  
			while(TI!=1);		//等待发送完成
			TI=0;  				//T1清零
	}
}

/*******************************************************************************
* 函数名         : UART_IRQHandler
* 功能		  	 : 串口中断服务函数，接收一帧数据 0x39起 0x93结束
* 输入			 : 无
* 输出			 : 无
*******************************************************************************/
void UART_IRQHandler() interrupt 4 
{
 
	if(RI==1)  			//收到数据
	{
	  
		res=SBUF;

		if((R_STA&0x80)==0)		//接收未完成
		{
			
			if((R_STA&0x40) == 0x40)	//接收到帧头
			{

				if(res != 0x93)
				{
					R_STA++;
					if((R_STA&0x3f)>(USART_SIZE-2))		//接收溢出，重新接收
					{
						R_STA = 0;
					}
					str[R_STA&0x3f] = res;	//存到缓存区
				}
				else
				{
					R_STA|=0x80;		//接收到帧尾，标志一帧数据接收完成
				}
			}
			else
			{
				if(res == 0x39)
				{
					R_STA |= 0x40;		//标志接收到帧头
				}
				else
				{
					R_STA = 0;
				}
			}
		}
	}
	RI = 0;
}